<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tr√°i tim 3D - T√∫ ch√∫c b√© ‚ù§Ô∏è</title>
<style>
  html,body { height:100%; margin:0; background:#000; font-family: Arial, sans-serif; }
  #container { width:100%; height:100vh; overflow:hidden; position:relative; }
  .ui {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    top: 12px;
    display:flex;
    gap:10px;
    z-index: 10;
  }
  .btn {
    background: rgba(255,255,255,0.06);
    color: #fff;
    border: 1px solid rgba(255,255,255,0.12);
    padding: 10px 14px;
    border-radius: 10px;
    cursor: pointer;
    backdrop-filter: blur(6px);
  }
  .btn:hover { transform: translateY(-2px); }
  .title {
    color: #fff;
    text-shadow: 0 6px 20px rgba(0,0,0,0.6);
    font-weight: 700;
    font-size: 14px;
    padding: 10px 14px;
    border-radius: 10px;
    background: linear-gradient(90deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
  }
  #credit {
    position: absolute;
    bottom: 12px;
    left: 12px;
    color: rgba(255,255,255,0.7);
    font-size: 13px;
    z-index:10;
  }
</style>
</head>
<body>
<div id="container"></div>

<div class="ui">
  <div class="title">T√∫ ch√∫c b√© m√£i vui, m√£i l√† b√© iu c·ªßa T√∫ ‚ù§Ô∏è</div>
  <button id="playBtn" class="btn">‚ñ∂ Ph√°t nh·∫°c (Ph√©p M√†u)</button>
  <button id="muteBtn" class="btn">üîä T·∫Øt ti·∫øng</button>
</div>

<div id="credit">B·∫•m Play ƒë·ªÉ b·∫≠t nh·∫°c ‚Ä¢ Thay file "phepmo.mp3" n·∫øu mu·ªën</div>

<!-- Three.js t·ª´ CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.151.3/build/three.min.js"></script>
<!-- Optional: OrbitControls (d√πng ƒë·ªÉ r√™ th·ª≠) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.151.3/examples/js/controls/OrbitControls.js"></script>

<script>
/* ========== C·∫•u h√¨nh v√† kh·ªüi t·∫°o c∆° b·∫£n ========== */
const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.0009);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.set(0, 25, 140);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
container.appendChild(renderer.domElement);

/* Controls (ch·ªâ d√πng ƒë·ªÉ ki·ªÉm tra/t√πy ch·ªânh - c√≥ th·ªÉ t·∫Øt) */
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;
controls.minDistance = 60;
controls.maxDistance = 300;
controls.autoRotate = false;

/* √Ånh s√°ng */
const hemi = new THREE.HemisphereLight(0xffe6f0, 0x220022, 0.9);
scene.add(hemi);
const point = new THREE.PointLight(0xff66aa, 1.6, 500);
point.position.set(50, 80, 50);
scene.add(point);

/* ========== N·ªÅn sao (particle background) ========== */
function makeStars(count=1000) {
  const geom = new THREE.BufferGeometry();
  const positions = new Float32Array(count * 3);
  for (let i = 0; i < count; i++) {
    const r = 400 + Math.random()*600;
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2*Math.random()-1);
    positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
    positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
    positions[i*3+2] = r * Math.cos(phi);
  }
  geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.4, transparent: true, opacity: 0.9 });
  const stars = new THREE.Points(geom, mat);
  scene.add(stars);
}
makeStars(1200);

/* ========== T·∫°o tr√°i tim b·∫±ng h·∫°t (particle heart) ========== */
/* Parametric heart curve (classic) */
function heartPoint(t) {
  // t in [0, 2PI]
  const x = 16 * Math.pow(Math.sin(t), 3);
  const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
  return new THREE.Vector3(x, y, 0);
}

/* T·∫°o cloud b·∫±ng c√°ch sinh nhi·ªÅu ƒëi·ªÉm quanh b·ªÅ m·∫∑t tr√°i tim */
function makeHeartParticles(num=6000) {
  const positions = new Float32Array(num*3);
  const colors = new Float32Array(num*3);
  for (let i=0;i<num;i++){
    // sample t along curve plus random radial jitter
    const t = Math.random() * Math.PI * 2;
    const base = heartPoint(t);
    // scale to size
    const scale = 2.6; // overall size
    // create some radial offset and depth
    const radial = (Math.random()**1.5) * 6; // how far from curve
    const angle = Math.random() * Math.PI*2;
    // small depth offset
    const z = (Math.random()-0.5) * 12;
    const px = (base.x + Math.cos(angle)*radial) * scale;
    const py = (base.y + Math.sin(angle)*radial*0.6) * scale * 0.9;
    const pz = z * (Math.random()*1.2) - 1.5;
    positions[i*3]=px;
    positions[i*3+1]=py+10; // shift heart up a bit
    positions[i*3+2]=pz;
    // color gradient from bright pink to deep pink
    const c = new THREE.Color().setHSL(0.98 - Math.random()*0.05, 0.9, 0.55 - Math.random()*0.08);
    colors[i*3]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;
  }
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  const material = new THREE.PointsMaterial({
    size: 1.8,
    vertexColors: true,
    blending: THREE.AdditiveBlending,
    depthTest: true,
    transparent: true,
    opacity: 0.95
  });
  const points = new THREE.Points(geometry, material);
  scene.add(points);
  return { points, geometry };
}
const heart = makeHeartParticles(7000);

/* G·ª£n/ƒë·∫≠p tr√°i tim: thay ƒë·ªïi scale theo time */
let time = 0;

/* ========== V√≤ng ch·ªØ xoay (sprites canvas) ========== */
function createTextSprite(message, parameters) {
  parameters = parameters || {};
  const font = parameters.font || "bold 42px Arial";
  const fillStyle = parameters.fillStyle || "rgba(255,255,255,0.95)";
  const background = parameters.background || "transparent";

  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const padding = 20;
  ctx.font = font;
  const textWidth = ctx.measureText(message).width;
  canvas.width = textWidth + padding*2;
  canvas.height = 60 + padding;
  // optional background
  if (background !== "transparent") {
    ctx.fillStyle = background;
    ctx.fillRect(0,0,canvas.width, canvas.height);
  }
  // glow effect
  ctx.shadowColor = "rgba(255,120,160,0.9)";
  ctx.shadowBlur = 14;
  // text
  ctx.fillStyle = fillStyle;
  ctx.textBaseline = "middle";
  ctx.textAlign = "center";
  ctx.font = font;
  ctx.fillText(message, canvas.width/2, canvas.height/2);

  const texture = new THREE.CanvasTexture(canvas);
  texture.minFilter = THREE.LinearFilter;
  const mat = new THREE.SpriteMaterial({ map: texture, transparent: true });
  const sprite = new THREE.Sprite(mat);
  // scale sprite depending on canvas size
  const scaleFactor = 0.18;
  sprite.scale.set(canvas.width*scaleFactor, canvas.height*scaleFactor, 1);
  return sprite;
}

const ringGroup = new THREE.Group();
scene.add(ringGroup);

function makeTextRing(text, radius=46, count=28) {
  ringGroup.clear?.(); // if available
  for (let i=0;i<count;i++){
    const sprite = createTextSprite(text, { font: "700 36px Arial", fillStyle: "rgba(255,255,255,0.95)" });
    // position on circle
    const ang = (i/count) * Math.PI*2;
    const x = Math.cos(ang) * radius;
    const z = Math.sin(ang) * radius;
    sprite.position.set(x, -24, z);
    // rotate to face outward a bit
    sprite.lookAt(0, -24, 0);
    // tilt for perspective
    sprite.material.rotation = ang + Math.PI/2;
    // random scale small variation
    const s = 0.85 + Math.random()*0.4;
    sprite.scale.multiplyScalar(s);
    ringGroup.add(sprite);
  }
}
makeTextRing("T√∫ ch√∫c b√© m√£i vui, m√£i l√† b√© iu c·ªßa T√∫ ‚ù§Ô∏è", 54, 36);

/* ========== Animation loop ========== */
function animate() {
  requestAnimationFrame(animate);
  time += 0.016;
  // subtle heartbeat scaling
  const beat = 1.0 + Math.sin(time*2.2) * 0.09; // speed/amplitude
  heart.points.scale.set(beat, beat, beat);

  // add a slow swirl to particles by slightly offsetting positions (cheap)
  const pos = heart.geometry.attributes.position;
  for (let i=0;i<pos.count;i++){
    const ix = i*3, iy = ix+1, iz = ix+2;
    const ox = pos.array[ix], oy = pos.array[iy], oz = pos.array[iz];
    // small oscillation depending on index and time
    const s = 0.6 * Math.sin(time*0.6 + i*0.0017);
    pos.array[iz] = oz + s*0.04;
  }
  pos.needsUpdate = true;

  // rotate the text ring slowly
  ringGroup.rotation.y += 0.008;
  // rotate slightly for 3D feeling
  ringGroup.rotation.x = Math.sin(time*0.3) * 0.06;

  // camera gentle orbit for cinematic effect (or comment out)
  camera.position.x = Math.sin(time*0.06) * 120;
  camera.position.z = Math.cos(time*0.06) * 140;
  camera.lookAt(0, 8, 0);

  controls.update();
  renderer.render(scene, camera);
}
animate();

/* ========== Handle resize ========== */
window.addEventListener('resize', ()=> {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ========== Audio: n√∫t Play/Pause ========== */
const audio = new Audio();
audio.src = "phepmo.mp3"; // <--- Thay file mp3 c·ªßa b·∫°n ·ªü ƒë√¢y (ho·∫∑c ƒë·ªïi th√†nh URL)
audio.loop = true;
audio.volume = 0.7;
let isPlaying = false;
const playBtn = document.getElementById('playBtn');
const muteBtn = document.getElementById('muteBtn');

playBtn.addEventListener('click', async ()=>{
  try {
    if (!isPlaying) {
      await audio.play();
      isPlaying = true;
      playBtn.textContent = "‚è∏ T·∫°m d·ª´ng nh·∫°c";
    } else {
      audio.pause();
      isPlaying = false;
      playBtn.textContent = "‚ñ∂ Ph√°t nh·∫°c (Ph√©p M√†u)";
    }
  } catch (err) {
    console.warn("Audio play failed:", err);
  }
});

muteBtn.addEventListener('click', ()=>{
  audio.muted = !audio.muted;
  muteBtn.textContent = audio.muted ? "üîá ƒê√£ t·∫Øt" : "üîä B·∫≠t ti·∫øng";
});

/* ========== Tips: n·∫øu mu·ªën t·ª± ƒë·ªông hi·ªán/·∫©n UI ========== */
/* B·∫°n c√≥ th·ªÉ ·∫©n controls sau v√†i gi√¢y ƒë·ªÉ full-screen ƒë·∫πp h∆°n */ 
let uiTimer;
function scheduleHideUI() {
  clearTimeout(uiTimer);
  document.querySelector('.ui').style.opacity = 1;
  uiTimer = setTimeout(()=> {
    document.querySelector('.ui').style.opacity = 0.06;
  }, 4000);
}
scheduleHideUI();
window.addEventListener('mousemove', scheduleHideUI);
</script>
</body>
</html>

